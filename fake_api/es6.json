[
    {"quotation": "TypedArrays provide “view”s of binary data buffers that align with various integer types, like 8-bit unsigned integers and 32-bit floats. The array access to binary data makes operations much easier to express and maintain, which enables you to more easily work with complex data like video, audio, canvas data, and so on."},
    {"quotation": "Maps are key-value pairs where the key can be an object instead of just a string/primitive. Sets are unique lists of values (of any type)."},
    {"quotation": "WeakMaps are maps where the key (object) is weakly held, so that GC is free to collect the entry if it’s the last reference to an object. WeakSets are sets where the value is weakly held, again so that GC can remove the entry if it’s the last reference to that object."},
    {"quotation": "Whereas a WeakMap holds its keys weakly (but its values strongly), a WeakSet holds its values weakly (there aren’t really keys)."},
    {"quotation": "If you use an object as a map key and that object is later discarded (all references unset) in attempt to have garbage collection (GC) reclaim its memory, the map itself will still retain its entry. You will need to remove the entry from the map for it to be GC-eligible."},
    {"quotation": "Array.of(..) replaces Array(..) as the preferred function-form constructor for arrays, because Array.of(..) does not have that special single-number-argument case."},
    {"quotation": "Array.from(..) looks to see if the first argument is an iterable, and if so, it uses the iterator to produce values to “copy” into the returned array. Because real arrays have an iterator for those values, that iterator is automatically used."},
    {"quotation": "Array#copyWithin(..) is a new mutator method available to all arrays (including typed arrays; see Chapter 5). copyWithin(..) copies a portion of an array to another location in the same array, overwriting whatever was there before."},
    {"quotation": "Symbols are likely going to be mostly used as special (meta) properties on objects. So the Object.getOwnPropertySymbols(..) utility was introduced, which retrieves only the symbol properties directly on an object"},
    {"quotation": "Many JavaScript libraries/frameworks provide utilities for copying/ mixing one object’s properties into another (e.g., jQuery’s extend(..)). There are various nuanced differences between these different utilities, such as whether a property with value undefined is ignored or not. ES6 adds Object.assign(..), which is a simplified version of these algorithms. The first argument is the target, and any other arguments passed are the sources, which will be processed in listed orde "},
    {"quotation": "The standard global isNaN(..) utility has been broken since its inception, in that it returns true for things that are not numbers, not just for the actual NaN value, because it coerces the argument to a number type (which can falsely result in a NaN). ES6 adds a fixed utility Number.isNaN(..) that works as it should"},
    {"quotation": "ES6 adds a Number.isInteger(..) helper utility that potentially can determine this quality slightly more efficiently. To chek if the number if float: Number.isFinite( x ) && !Number.isInteger( x )"},
    {"quotation": "If a function has a name value assigned, that’s typically the name used in stack traces in developer tools."},
    {"quotation": "Well-Known Symbols: @@isConcatSpreadable, @@toPrimitive, @@species (which constructor), @@unscopables (depticated 'with'), @@iterator, @@toStringTag, @@hasInstance"},
    {"quotation": "A proxy is a special kind of object you create that “wraps”—or sits in front of—another normal object. You can register special handlers (aka traps) on the proxy object, which are called when various operations are performed against the proxy. These handlers have the opportunity to perform extra logic in addition to forwarding the operations on to the original target/wrapped object.<br/>The Reflect object is a plain object (like Math), not a function/constructor like the other built-in natives.<br/>It holds static functions that correspond to various meta programming tasks you can control. These functions correspond one-to-one with the handler methods (traps) that proxies can define."},
    {"quotation": "Proper Tail Calls (PTC) of these forms can be optimized—called Tail Call Optimization (TCO)—so that the extra stack frame allocation is unnecessary. Instead of creating a new stack frame for the next function call, the engine just reuses the existing stack frame. That works because a function doesn’t need to preserve any of the current state, as nothing happens with that state after the PTC. (only strict mode)"}
]